# You Want Salt With That? Part Three: Salt The Hash

[Eric Lippert](https://social.msdn.microsoft.com/profile/Eric%20Lippert) 2/3/2005 6:53:00 AM

-----

Last time we were considering what happens if an attacker gets access to your server's password file. If the passwords themselves are stored in the file, then the attacker's work is done. If they're hashed and then stored, and the hash algorithm is strong, then there's not much to do other than to hash every string and look through the password file for that hash. If there's a match, then you've discovered the user's password. You don't have to look through the vast space of strings in alphabetical order of course. An attacker will start with a dictionary of likely password strings. We want to find some way to make that attacker work harder. Setting a policy which disallows common dictionary words as passwords would be a good idea. Another technique is to spice up the hashes a bit with some salt. **System \#3** For every user name we generate a random unique string of some fixed length.  That string is called the “salt”.  We now store the username, the salt and the hash of the string formed by concatenating the user’s password to the salt. If user Alpha's password is "bigsecret" and the salt is "Q3vd" then we'll hash "Q3vdbigsecret". Since every user has their own unique random salt, two users who happen to have the same password get different salted hashes.  And the dictionary attack is foiled; the attacker cannot compute the hashes of every word in a dictionary once and then check every hash in the table for matches anymore.  Rather, the attacker is going to have to re-hash the entire dictionary anew for every salt.  A determined attacker who has compromised the server will have to mount an entire new dictionary attack against every user’s salted hash, rather than being able to quickly scan the list for known hashes. Salting essentially makes it less feasible to attack every user at once when the password file is compromised; the attacker must start a whole new attack for each user.  Still, given enough time and weak passwords, an attacker can recover passwords. In this system the client sends the username and password to the server, the server appends the password to the salt, hashes the result, and compares the result to the salted hash in the table.  This answers the original question posed by the JOS poster; the salt can be public because it is just a random string. Ideally, both the salt and the salted hash would be kept private so that an attacker would not be able to mount a dictionary attack against that salt.  But there is no way to deduce any information whatsoever just from the salt. And of course, it's better to not get into this situation in the first place -- don't allow your password list to be stolen\! But it's a good idea for a security system to not rely on other security systems for its own security. We call this idea "defense in depth". You want to make the attacker have to do many impossible things to compromise your security, so that if just one of those impossible things turns out to be possible after all, you're not sunk.  But what about the fact that the password goes over the wire in the clear, where anyone can eavesdrop? That's now the weak point of this system. Can we do something about that? Tune in next time and we'll see what we can come up with.

