# Future-Proofing A Design

[Eric Lippert](https://social.msdn.microsoft.com/profile/Eric%20Lippert) 1/16/2009 12:21:00 PM

-----

Last time on FAIC a user asked for guidance on the potential pitfalls of refactoring an automatic property into a regular explicit property. This is just an example of a far more general problem: how can we design programs so that they are easy to get right when things inevitably change in the future?

This is an incredibly difficult question to answer, one which whole books could be written on. Today, I'll just give three general points to think about.

First: Premature generality is expensive. **** Designing code to be future-proof without a clear understanding of what the future holds often leads to excess generality; generality has very real costs, and they might be higher than the benefit accrued. If you do a good job of solving the problem at hand with the tools at hand, if the code is clean and organized and has few moving parts, then it will be easier to generalize it in the future if you need to in order to solve a problem then. **Design your code to solve the well-understood problem.** If you design it to solve an unknown future problem, odds are good that you're going to solve it poorly, making even more work for the future. Second: Represent in your *model* only those things which are *always* in the problem domain and whose class relationships are *unchanging*. The relationships between the classes TrafficLight, TrafficSign, Vehicle, Car, Truck, Pedestrian, Roadway, Intersection, SignalTiming and RightOfWayLaw are likely to be eternal and unchanging. Things change. The *semantics* of a particular RightOfWayLaw might change subtly or grossly as the city council does its job. There might be *new subclasses* of Vehicle created in the future. A specific traffic light might have a *faulty implementation* that the rest of the system needs to handle gracefully. But each of these situations is about changing the implementation details of a class, never changing its *relationships* with other classes. If the class *relationships* are future-proofed then it is a lot easier to edit the *implementations* of those classes without having to worry that the whole system will thereby get messed up. The easiest way to keep the relationships straight is to **base them as much as possible on concepts directly from the problem domain**. Third: Keep your policies away from your mechanisms. The *mechanism* of a traffic light works the same way no matter what *policies* like light timings at rush hour are.  If mechanisms (TrafficLight) are separated from policies (SignalTiming) then you can change the mechanism to a more efficient one without worrying that you’re going to inadvertently change policy, and can change policy without worrying that you’re going to break mechanism. My earlier example of a bank balance was deliberately an example of what goes wrong when mechanism and policy become conflated. The “Balance” getter was originally a *mechanism*, but after the edit, it became a *security policy enforcement tool*. You must then ask yourself, “where in this code do I care about *enforcing* the policy, and where do I care about *executing* the mechanism?” and make the appropriate edits. After the edit, everywhere that needs policy enforcement needs to use “Balance”, everywhere that needs to effect the action of the mechanism needs to use “balance”.  What are the odds that there is going to be a bug introduced, given that we now have a difference which is important and almost invisible? Pretty high\! This difference should probably be made more visible by renaming the backing store to something that calls it out as semantically different from the property accessor.

Let's bring this back to the question at hand. What guidance do we propose for future-proofing turning automatic properties into regular properties?  The guidance that I am proposing here is:

  - First, think about whether making the design general now to solve an unknown problem that you might not even have in the future is worthwhile.
  - Second, make sure that the design in general makes the relationships between classes unchanging, even if the specifics of each class change.
  - Third, consider whether that hypothetical future change to the property will be splitting apart its role as a mechanism from its role as an enforcer of policy; if this is going to be an important distinction, then consider getting that distinction into the class implementation early so that you don’t have to retrofit it in a tedious and error-prone manner later.

